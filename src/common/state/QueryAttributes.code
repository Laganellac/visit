Initialization: defaultVars
    defaultVars.push_back("default");

Function: SetVariables
Declaration: void SetVariables(const stringVector &variables_);
Definition:
void
QueryAttributes::SetVariables(const stringVector &variables_)
{
   queryInputParams["vars"] = variables_;
}

Function: GetName
Declaration: const std::string &GetName() const;
Definition:
const std::string &
QueryAttributes::GetName() const
{
    if (queryInputParams.HasEntry("query_name"))
        return queryInputParams.GetEntry("query_name")->AsString();
    return defaultName;
}

Function: GetName2
Declaration: std::string &GetName();
Definition:
std::string &
QueryAttributes::GetName()
{
    if (queryInputParams.HasEntry("query_name"))
        return queryInputParams.GetEntry("query_name")->AsString();
    return defaultName;
}

Function: GetVariables
Declaration: const stringVector &GetVariables() const;
Definition:
const stringVector &
QueryAttributes::GetVariables() const
{
    if (queryInputParams.HasEntry("vars"))
        return queryInputParams.GetEntry("vars")->AsStringVector();
    return defaultVars;
}

Function: GetVariables2
Declaration: stringVector &GetVariables();
Definition:
stringVector &
QueryAttributes::GetVariables()
{
    if (queryInputParams.HasEntry("vars"))
        return queryInputParams.GetEntry("vars")->AsStringVector();
    return defaultVars;
}

Function: Reset
Declaration: void Reset();
Definition:
void
QueryAttributes::Reset()
{
    resultsMessage  = " ";
    xUnits = "";
    yUnits = "";
    if (!varTypes.empty())
    {
         varTypes.clear();
    }
    if (!resultsValue.empty())
    {
        resultsValue.clear();
        resultsValue.push_back(0.);
    }
    pipeIndex = -1;

    queryInputParams.Reset();

    SelectAll();
}

Function: PrintSelf
Declaration: void PrintSelf(ostream &os);
Definition:
void
QueryAttributes::PrintSelf(ostream &os)
{
    os << "\n" << GetName().c_str() << ":  ";
    os << "selected variables: ";
    stringVector &v = GetVariables();
    for (size_t i = 0; i < v.size(); i++)
        os << v[i].c_str() << "  ";
    os << "\n";
    os << "Results: <" << resultsMessage.c_str() << ">\n";
}

Function: SetResultsValue
Declaration: void SetResultsValue(const double);
Definition:
void
QueryAttributes::SetResultsValue(const double val)
{
    resultsValue[0] = val;
}

Function: SetResultsValues
Declaration: void SetResultsValues(const double*, const int);
Definition:
void
QueryAttributes::SetResultsValues(const double *vals, const int numVals)
{
    int i;
    resultsValue.clear();
    for (i = 0; i < numVals; ++i)
        resultsValue.push_back(vals[i]);
}

Function: Compress
Declaration: void Compress(unsigned long inSize, const void *in);
Definition:
void
QueryAttributes::Compress(unsigned long inSize, const void *in)
{
    compressedResults.clear();

    // No data to compress
    if(inSize == 0 || in == nullptr)
    {
        debug2 << "QueryAttributes::Compress called with the arguments "
            << inSize << " and " << in << " resulting in a no-op."
            << std::endl;
        return;
    }

    const std::string timerString = "Compressing query results";
    int t0 = visitTimer->StartTimer();
#ifdef QA_NO_COMPRESSION
    compressedResults.resize(inSize);
    memcpy(compressedResults.data(), in, inSize);
#else
    // Use default compression
    int level = Z_DEFAULT_COMPRESSION;
    z_stream zStream;
    memset(&zStream, 0, sizeof(z_stream));
    int zret = deflateInit(&zStream, level);
    if(zret != Z_OK)
    {
        // Throw an exception
        std::cout << "ERROR! deflateInit was not Z_OK!" << std::endl;
        return;
    }

    // Assume the inSize is enough to hold the compressed size
    compressedResults.resize(inSize, 0);
    zStream.avail_in = inSize;
    zStream.next_in = (Bytef*)in;
    zStream.avail_out = inSize;
    zStream.next_out = compressedResults.data();
    zret = deflate(&zStream, Z_FINISH);
    if(zret != Z_STREAM_END)
    {
        // Throw an exception
        std::cout << "ERROR! deflate was not able to complete deflation "
            << "in one call! Code" << zret << "." << std::endl;
        compressedResults.clear();
        deflateEnd(&zStream);
        visitTimer->StopTimer(t0, timerString);
        return;
    }
    compressedResults.resize(inSize - zStream.avail_out);
    deflateEnd(&zStream);
#endif
    visitTimer->StopTimer(t0, timerString);
    debug5 << "Compressed " << inSize << " in to " << compressedResults.size()
        << std::endl;
}

Function: Decompress
Declaration: void Decompress(unsigned long outSize, void *out);
Definition:
void
QueryAttributes::Decompress(unsigned long outSize, void *out)
{
    // Nothing to do.
    if(outSize == 0 || out == nullptr)
    {
        debug2 << "QueryAttributes::Decompress called with the arguments "
            << outSize << " and " << out << " resulting in a no-op."
            << std::endl;
        return;
    }

    if(compressedResults.empty())
    {
        // Throw an exception.
        std::cout << "ERROR! compressedResults is empty!" << std::endl;
        return;
    }

    const std::string timerString = "Decompressing query results";
    int t0 = visitTimer->StartTimer();
#ifdef QA_NO_COMPRESSION
    memcpy(out, compressedResults.data(), outSize);
#else
    // Initialize inflation
    z_stream zStream;
    memset(&zStream, 0, sizeof(z_stream));
    int zret = inflateInit(&zStream);
    if(zret != Z_OK)
    {
        // Throw an exception
        std::cout << "ERROR! inflateInit was not Z_OK!" << std::endl;
        visitTimer->StopTimer(t0, timerString);
        return;
    }

    // Inflate the data
    zStream.avail_in = compressedResults.size();
    zStream.next_in = compressedResults.data();
    zStream.avail_out = outSize;
    zStream.next_out = (Bytef*)out;
    zret = inflate(&zStream, Z_FINISH);
    if(zret != Z_STREAM_END)
    {
        // Throw an exception
        std::cout << "ERROR! inflate was not able to complete inflation "
            << "in one call! Code" << zret << "." << std::endl;
        inflateEnd(&zStream);
        visitTimer->StopTimer(t0, timerString);
        return;
    }
    compressedResults.clear();
    inflateEnd(&zStream);
#endif
    visitTimer->StopTimer(t0, timerString);
}

Function: Move Assignment
Declaration: QueryAttributes &operator=(QueryAttributes&&);
Definition:
QueryAttributes &
QueryAttributes::operator=(QueryAttributes &&obj)
{
    Move(std::move(obj));
    return *this;
}

Function: Move Constructor
Declaration: QueryAttributes(QueryAttributes&&);
Definition:
QueryAttributes::QueryAttributes(QueryAttributes &&obj)
    : AttributeSubject(QueryAttributes::TypeMapFormatString)
{
    Move(std::move(obj));
}

Function: Move
Declaration: void Move(QueryAttributes&&);
Definition:
void
QueryAttributes::Move(QueryAttributes &&obj)
{
    resultsMessage = std::move(obj.resultsMessage);
    resultsValue = std::move(obj.resultsValue);
    timeStep = obj.timeStep;
    varTypes = std::move(obj.varTypes);
    pipeIndex = obj.pipeIndex;
    xUnits = std::move(obj.xUnits);
    yUnits = std::move(obj.yUnits);
    floatFormat = std::move(obj.floatFormat);
    xmlResult = std::move(obj.xmlResult);
    suppressOutput = obj.suppressOutput;
    queryInputParams = obj.queryInputParams;
    defaultName = std::move(obj.defaultName);
    defaultVars = std::move(obj.defaultVars);
    compressedResults = std::move(obj.compressedResults);
}

